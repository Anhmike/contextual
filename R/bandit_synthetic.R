#' @export
SyntheticBandit <- R6::R6Class(
  inherit = BasicBandit,
  portable = TRUE,
  class = FALSE,
  public = list(
    d             = NULL,
    k             = NULL,
    reward_means  = NULL,
    reward_stds   = NULL,
    reward_family = NULL,
    has_cache     = NULL,
    precaching    = NULL,
    weights   = NULL,
    class_name = "SyntheticBandit",
    initialize   = function(
      reward_family        = 'Bernoulli',
      reward_means         = 4.0,
      reward_stds          = 1.0,
      weights              = NULL,
      precaching           = TRUE
    ) {
      if (!(reward_family %in% c("Bernoulli","Gaussian","Poisson"))) {
        stop('Reward family needs to be one of "Bernoulli", "Gaussian" or "Poisson".' , call. = FALSE)
      }
      if (is.vector(self$weights)) self$weights <- matrix(self$weights, nrow = 1L)
      super$initialize(weights)
      self$has_cache            <- FALSE
      self$precaching           <- precaching
      self$reward_family        <- reward_family
      self$reward_means         <- reward_means
      self$reward_stds          <- reward_stds
    },
    set_weights = function(local_W) {
      if (is.vector(local_W)) private$W <- matrix(local_W, nrow = 1L)
      if (is.matrix(local_W)) private$W <- local_W
      self$d <- as.integer(dim(private$W)[1])
      self$k <- as.integer(dim(private$W)[2])
      invisible(private$W)
    },
    get_context = function(t) {
      if (self$precaching) {
        private$context_to_list(t)
      } else {
        self$generate_bandit_data(n = 1L)
        private$context_to_list(t = 1)
      }
    },
    get_reward = function(t, context, action) {
      private$reward_to_list(t, action)
    },
    generate_bandit_data = function(n = 1L, silent = TRUE ) {
      if (!silent) message("Precaching bandit" )
      private$O <- matrix(0, self$k, n)
      private$R <- matrix(0, self$k, n)
      private$generate_context(n)
      private$generate_weights(n)
      private$generate_rewards(n)
      self$has_cache <- TRUE
    }
  ),
  private = list(
    W = NULL,
    R = NULL,
    X = NULL,
    O = NULL,
    context_list = list(),
    reward_list = list(),
    generate_context = function(n = 1L) {
      #private$X <- array(sample(c(0, 1), replace = TRUE, size = self$d * self$k * n), dim = c(self$d, self$k, n))
      private$X <- array(sample(c(0, 1), replace = TRUE, size = self$d * n), dim = c(self$d, self$k, n))
      private$X
    },
    generate_weights = function(n) {
      weight_array  <- array(t(matrix(private$W, self$k , self$d, byrow = TRUE )), dim = c(self$d, self$k, n))
      Wg <- private$X*weight_array
      private$O <- colSums(Wg)
      private$O[is.nan(private$O)] <- 0
    },
    generate_rewards = function(n) {
      rwrd_n <- self$k * n
      if (self$reward_family == 'Bernoulli') {
        private$R <- round((runif(rwrd_n) + private$O) / 2)
      } else if (self$reward_family == 'Gaussian') {
        private$R <- (rnorm(rwrd_n, self$reward_means, self$reward_stds) + private$O) / 2
      } else if (self$reward_family == 'Poisson') {
        private$R <- (rpois(rwrd_n, self$reward_means) + private$O) / 2
      }
    },
    context_to_list = function(t) {
      if (self$precaching) idx <- t else idx <- 1
      k <- self$k
      list(
        k = self$k,
        d = self$d,
        X = private$X[,, idx],
        o = which_max_tied(private$O[, idx])
      )
    },
    reward_to_list = function(t, action) {
      if (self$precaching) idx <- t else idx <- 1
      list(
        reward = private$R[action$choice, idx],
        optimal_reward_value = as.double(private$R[which_max_tied(private$O[, idx]), idx])
      )
    }
  )
)

#' Bandit: SyntheticBandit
#'
#' SyntheticBandit intro
#'
#' @name SyntheticBandit
#' @family contextual subclasses
#'
#' @section Usage:
#' \preformatted{b <- SyntheticBandit$new()
#'
#' b$reset()
#'
#' print(b)
#' }
#'
#' @section Arguments:
#' \describe{
#'   \item{b}{A \code{SyntheticBandit} object.}
#' }
#'
#' @section Details:
#' \code{$new()} starts a new SyntheticBandit, it uses \code{\link[base]{pipe}}.
#' R does \emph{not} wait for the process to finish, but returns
#' immediately.
#'
#' @seealso
#'
#' Core contextual classes: \code{\link{Bandit}}, \code{\link{Policy}}, \code{\link{Simulator}},
#' \code{\link{Agent}}, \code{\link{History}}, \code{\link{Plot}}
#'
#'
NULL
