#' @export
Policy <- R6::R6Class(
  "Policy",
  portable = FALSE,
  class = FALSE,
  public = list(
    name          = "",
    action        = NULL,
    theta         = NULL,
    theta_to_arms = NULL,
    k             = NULL,
    d             = NULL,
    initialize = function(name = "Not implemented") {
      self$theta <- list()
      self$name   <- name
      self$action <- list()
    },
    get_action = function(t, context) {
      # Selects an arm based on self$theta and context, returns it in action$choice.
      stop("Policy$get_action() has not been implemented.", call. = FALSE)
    },
    set_reward = function(t, context, action, reward) {
      # Updates parameters in theta based on reward awarded by bandit.
      stop("Policy$set_reward() has not been implemented.", call. = FALSE)
    },
    set_parameters = function() {
      # Policy parameter (not theta!) initialisation happens here.
      stop("Policy$set_parameters() has not been implemented.", call. = FALSE)
    },
    initialize_theta = function() {
      # Called during contextual's initialisation.
      # Copies theta_to_arms k times, makes the copies available through theta.
      if (!is.null(self$theta_to_arms)) {
        for (param_index in seq_along(self$theta_to_arms)) {
          self$theta[[ names(self$theta_to_arms)[param_index] ]] <- rep(list(self$theta_to_arms[[param_index]]),self$k)
        }
      }
      self$theta
    },
    set_theta = function(theta) {
      self$theta <- theta
    }
  )
)



#' Policy
#'
#' The R6 class \code{Policy} is the parent class of all \code{Policy} implementations in
#' \code{\{contextual\}}. Classes that extend this abstract \code{Policy}
#' superclass are expected to take into account the current \code{d} dimensional \code{context},
#' together with a limited set of parameters denoted \code{theta} (summarizing all past actions),
#' to choose one of a \code{Bandit}'s arms at each time step \code{t}.
#' On choosing one of the {k} arms of the Bandit and receiving its corresponding \code{reward},
#' the \code{Policy} then uses the current \code{context}, \code{action} and \code{reward} to
#' update its set of parameters \code{theta}.
#'
#' @name Policy
#' @family contextual policies
#'
#' @section Usage:
#' \preformatted{
#'   policy <- Policy$new()
#' }
#'
#' @section Arguments:
#'
#' \describe{
#'   \item{\code{name}}{
#'    A character string identifying this \code{Policy} It is, amongst others, saved to the \code{History} log
#'    and displayed in summaries and plots.
#'   }
#' }
#'
#' @section Methods:
#'
#' \describe{
#'   \item{\code{new(name)}}{
#'     Generates and initializes a new \code{Policy} object.
#'     A \code{Policy} needs to add the parameters it needs to keep track of to list \code{self$theta}
#'     during the \code{Policy}'s initialisation.
#'   }
#'
#'   \item{\code{set_parameters()}}{
#'    This helper function, called during a Policy's initialisation, assigns the values
#'    it finds in list \code{self$theta_to_arms} to each of the Policy's k arms.
#'    The parameters defined here can then be accessed by arm index in the following way:
#'    \code{theta[[index_of_arm]]$parameter_name}.
#'   }
#'
#'   \item{\code{get_action(t, context)}}{
#'     Here, a \code{Policy} chooses an arm to play based on the current values
#'     of its parameters \code{theta} and the current \code{context}.
#'     Returns an \code{action} list that contains the index of the suggested arm as \code{action$choice}.
#'    }
#'
#'   \item{\code{set_reward(t, context, action, reward)}}{
#'     \code{set_reward} updates parameter values in \code{theta}
#'     based on the \code{action} taken, the \code{reward} received, and the current \code{context}.
#'    }
#'   }
#'
#' @seealso
#'
#' Core contextual classes: \code{\link{Simulator}},
#' \code{\link{Agent}}, \code{\link{History}}, \code{\link{Plot}}
#'
#' Bandit classes: \code{\link{Bandit}}, \code{\link{BasicBandit}},
#' \code{\link{LiSamplingOfflineBandit}}, \code{\link{SyntheticBandit}}
#'
NULL
